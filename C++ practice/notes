1)For reference type parameter arguement should be lvalue ,  

vector<int> getVector(){
	vector<int> v;
	return v;
}

vector<int> fillVector(vector<int> v){// no error this will work
	cout<<"first";
	return v;
}

vector<int> fillVector(vector<int>& v){ // error arguement passed not an l value
	cout<<"second";
	return v;
}

int main()
{
	vector<int> v = fillVector(getVector());

}

O/P
first

if both are prsent then no error as it will call (vector<int> v ) version

2)

 
 NOTE : 
 memcpy takes size in bytes so to copy 10 integers use :
 10*sizeof(int)
 
 
 3)
 Let's see what O(V+E) time means. Assume for the moment that E≥V, which is the case for most graphs, especially those for which 
 we run breadth-first search. Then V+∣E∣≤∣E∣+∣E∣=2⋅∣E∣. Because we ignore constant factors in asymptotic notation, we see that 
 when E≥V, O(V+E) really means O(E). If, however, we have E<∣V∣, then V+∣E∣≤∣V∣+∣V∣=2⋅∣V∣, and so O(V+E) really means O(V). 
 We can put both cases together by saying that O(V+E) really means O(max(V,E)). In general, if we have parameters x and y, then O(x+y) 
 really means O(max(x,y)).
 
 4)
 initialize static variable before use
 
 class A{
 public :
 	static int var;
 }
 
 int A::var = 0;
 
 5) void * pointer arithmetic can't be performed because void is an incomplete type but still addition and subtraction on void * 
 behaves same as char * 
void * ptr = (void*)malloc(sizeof(float)*5);
	printf("%d\n",ptr); // print 100
	ptr = ptr - 5;
	printf("%d\n",ptr); // print 95
	
	
 
6)
std::list<pair<string,int> > not std::list<pair<string,int>>
note the space between the last 2 angular brackets


7)
Deletion in symbol tables generally involves one of two strategies: lazy deletion, where we associate keys in the table with null,
 then perhaps remove all such keys at some later time, and eager deletion, where we remove the key from the table immediately.
  As just discussed, the code put(key, null) is an easy (lazy) implementation of delete(key). When we give an (eager) 
  implementation of delete(), it is intended to replace this default. 
  
8)
While this method does the job, it has a flaw that might cause performance problems in some practical situations. The problem is 
that the choice of using the successor is arbitrary and not symmetric. Why not use the predecessor? 

Since we keep on deleting only from right side in case of successor therefore tree becomes skewed towards left 
one solution could be to alternate between left and right depending upon whether tree has even or odd no of nodes 

9)
Suppose we wish to repeatedly search a linked list of length N elements, each of which contains a very long string key. 
How might we take advantage of the hash value when searching the list for an element with a given key? 
Solution: precompute the hash value of each string in the list. When searching for a key t, compare its hash value to the hash
 value of a string s. Only compare the string s and t if their hash values are equal. 
 
 

10)
CLRS page 365
DP has 2 approaches :
a) Top down : in this more no of function calls but need not go to all subproblems i.e. solve all cmaller subproblems
b)bottom up : in this it solves subproblems in increasing order of size , therefore , less function calls but has to solve all 
				subproblems which may not be required sometimes to get required solution 
				
11)
memset can be used to only set character bytes because it sets characters so can't be used to set integer array 

12)For data structures with random access iterators like array , vectors you can use sort(arr) or qsort(v.begin() , v.end())
but for other data structures with no random access like list use class inbuilt function i.e.  list.sort()

13)std::binary_search (myints,myints+9, 3)
just returns whether an element exists or not i.e. bool not its position for finding position use find()
